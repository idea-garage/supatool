import { Client } from 'pg';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';

interface SeedGenOptions {
  connectionString: string;
  tablesYamlPath: string;
  outputDir: string;
}

/**
 * 指定テーブルのデータをリモートDBから取得し、AI用シードJSONを生成
 * @param options SeedGenOptions
 */
export async function generateSeedsFromRemote(options: SeedGenOptions): Promise<void> {
  // tables.yaml読み込み
  const yamlObj = yaml.load(fs.readFileSync(options.tablesYamlPath, 'utf8')) as any;
  if (!yamlObj || !Array.isArray(yamlObj.tables)) {
    throw new Error('tables.yamlの形式が不正です。tables: [ ... ] で指定してください');
  }
  const tables: string[] = yamlObj.tables;

  // 日時付きサブディレクトリ名生成（例: 20250705_1116_supatool）
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth() + 1).padStart(2, '0');
  const d = String(now.getDate()).padStart(2, '0');
  const hh = String(now.getHours()).padStart(2, '0');
  const mm = String(now.getMinutes()).padStart(2, '0');
  const folderName = `${y}${m}${d}_${hh}${mm}_supatool`;
  const outDir = path.join(options.outputDir, folderName);

  // 出力ディレクトリ作成
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
  }

  // DB接続
  const client = new Client({ connectionString: options.connectionString });
  await client.connect();

  let processedCount = 0;
  for (const tableFullName of tables) {
    // スキーマ指定なし→public
    let schema = 'public';
    let table = tableFullName;
    if (tableFullName.includes('.')) {
      [schema, table] = tableFullName.split('.');
    }
    // データ取得
    const res = await client.query(`SELECT * FROM "${schema}"."${table}"`);
    const rows = res.rows;
    // ファイル名
    const fileName = `${table}_seed.json`;
    const filePath = path.join(outDir, fileName);
    // 出力JSON
    const json = {
      table: `${schema}.${table}`,
      fetched_at: now.toISOString(),
      fetched_by: 'supatool v0.3.5',
      note: 'This data is a snapshot of the remote DB at the above time. For AI coding reference. You can update it by running the update command again.',
      rows
    };
    fs.writeFileSync(filePath, JSON.stringify(json, null, 2), 'utf8');
    processedCount++;
  }

  await client.end();

  // llms.txtインデックス出力（supabase/seeds直下に毎回上書き）
  const files = fs.readdirSync(outDir);
  const seedFiles = files.filter(f => f.endsWith('_seed.json'));
  let llmsTxt = `# AI seed data index (generated by supatool)\n`;
  llmsTxt += `# fetched_at: ${now.toISOString()}\n`;
  llmsTxt += `# folder: ${folderName}\n`;
  for (const basename of seedFiles) {
    const file = path.join(outDir, basename);
    const content = JSON.parse(fs.readFileSync(file, 'utf8'));
    // テーブルコメント（なければ空）
    let tableComment = '';
    try {
      const [schema, table] = content.table.split('.');
      const commentRes = await getTableComment(options.connectionString, schema, table);
      if (commentRes) tableComment = commentRes;
    } catch {}
    llmsTxt += `${content.table}: ${basename} (${Array.isArray(content.rows) ? content.rows.length : 0} rows)`;
    if (tableComment) llmsTxt += ` # ${tableComment}`;
    llmsTxt += `\n`;
  }
  const llmsPath = path.join(options.outputDir, 'llms.txt');
  fs.writeFileSync(llmsPath, llmsTxt, 'utf8');

  // 英語でまとめて出力
  console.log(`Seed export completed. Processed tables: ${processedCount}`);
  console.log(`llms.txt index written to: ${llmsPath}`);
}

// テーブルコメント取得ユーティリティ
async function getTableComment(connectionString: string, schema: string, table: string): Promise<string | null> {
  const client = new Client({ connectionString });
  await client.connect();
  try {
    const res = await client.query(
      `SELECT obj_description(c.oid) as comment FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid WHERE c.relname = $1 AND n.nspname = $2 AND c.relkind = 'r'`,
      [table, schema]
    );
    if (res.rows.length > 0 && res.rows[0].comment) {
      return res.rows[0].comment;
    }
    return null;
  } finally {
    await client.end();
  }
} 